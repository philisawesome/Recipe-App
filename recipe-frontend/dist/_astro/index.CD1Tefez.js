import{r as n,a as E}from"./index.C6H8Wuh2.js";import{j as x}from"./index.BnYiHOMz.js";function j(e,o,{checkForDefaultPrevented:t=!0}={}){return function(c){if(e?.(c),t===!1||!c.defaultPrevented)return o?.(c)}}function _(e,o){const t=n.createContext(o),i=u=>{const{children:s,...r}=u,f=n.useMemo(()=>r,Object.values(r));return x.jsx(t.Provider,{value:f,children:s})};i.displayName=e+"Provider";function c(u){const s=n.useContext(t);if(s)return s;if(o!==void 0)return o;throw new Error(`\`${u}\` must be used within \`${e}\``)}return[i,c]}function y(e,o=[]){let t=[];function i(u,s){const r=n.createContext(s),f=t.length;t=[...t,s];const d=l=>{const{scope:v,children:p,...m}=l,C=v?.[e]?.[f]||r,h=n.useMemo(()=>m,Object.values(m));return x.jsx(C.Provider,{value:h,children:p})};d.displayName=u+"Provider";function a(l,v){const p=v?.[e]?.[f]||r,m=n.useContext(p);if(m)return m;if(s!==void 0)return s;throw new Error(`\`${l}\` must be used within \`${u}\``)}return[d,a]}const c=()=>{const u=t.map(s=>n.createContext(s));return function(r){const f=r?.[e]||u;return n.useMemo(()=>({[`__scope${e}`]:{...r,[e]:f}}),[r,f])}};return c.scopeName=e,[i,S(c,...o)]}function S(...e){const o=e[0];if(e.length===1)return o;const t=()=>{const i=e.map(c=>({useScope:c(),scopeName:c.scopeName}));return function(u){const s=i.reduce((r,{useScope:f,scopeName:d})=>{const l=f(u)[`__scope${d}`];return{...r,...l}},{});return n.useMemo(()=>({[`__scope${o.scopeName}`]:s}),[s])}};return t.scopeName=o.scopeName,t}function M(e){const o=n.useRef(e);return n.useEffect(()=>{o.current=e}),n.useMemo(()=>(...t)=>o.current?.(...t),[])}var R=globalThis?.document?n.useLayoutEffect:()=>{},b=E[" useInsertionEffect ".trim().toString()]||R;function k({prop:e,defaultProp:o,onChange:t=()=>{},caller:i}){const[c,u,s]=P({defaultProp:o,onChange:t}),r=e!==void 0,f=r?e:c;{const a=n.useRef(e!==void 0);n.useEffect(()=>{const l=a.current;l!==r&&console.warn(`${i} is changing from ${l?"controlled":"uncontrolled"} to ${r?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),a.current=r},[r,i])}const d=n.useCallback(a=>{if(r){const l=w(a)?a(e):a;l!==e&&s.current?.(l)}else u(a)},[r,e,u,s]);return[f,d]}function P({defaultProp:e,onChange:o}){const[t,i]=n.useState(e),c=n.useRef(t),u=n.useRef(o);return b(()=>{u.current=o},[o]),n.useEffect(()=>{c.current!==t&&(u.current?.(t),c.current=t)},[t,c]),[t,i,u]}function w(e){return typeof e=="function"}export{j as a,M as b,y as c,R as d,_ as e,k as u};
